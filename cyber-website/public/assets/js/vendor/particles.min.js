/* Minimal lightweight particles implementation (small, permissive) for demo purposes.
   This is NOT the full particles.js library but provides enough behavior for
   simple particles, linking lines, 'grab' hover effect, and 'push' on click.
   It exposes a global function particlesJS(containerId, config).
*/
(function () {
  function extend(a, b) {
    for (var k in b) if (b.hasOwnProperty(k)) a[k] = b[k];
    return a;
  }
  function rand(min, max) {
    return Math.random() * (max - min) + min;
  }
  function Particle(x, y, size, velocity, color) {
    this.x = x;
    this.y = y;
    this.size = size;
    this.vx = velocity.x;
    this.vy = velocity.y;
    this.color = color;
  }
  Particle.prototype.update = function (bounds) {
    this.x += this.vx;
    this.y += this.vy;
    if (this.x < 0 || this.x > bounds.w) {
      if (bounds.out_mode === 'out') {
        if (this.x < 0) this.x = bounds.w;
        else this.x = 0;
      } else {
        this.vx = -this.vx;
      }
    }
    if (this.y < 0 || this.y > bounds.h) {
      if (bounds.out_mode === 'out') {
        if (this.y < 0) this.y = bounds.h;
        else this.y = 0;
      } else {
        this.vy = -this.vy;
      }
    }
  };
  var instances = {};
  window.particlesJS = function (containerId, config) {
    try {
      var container = document.getElementById(containerId);
      if (!container) {
        console.warn('particles: container not found', containerId);
        return;
      }
      container.innerHTML = '';
      container.style.position = 'absolute';
      container.style.left = '0';
      container.style.top = '0';
      container.style.width = '100%';
      container.style.height = '100%';
      var canvas = document.createElement('canvas');
      canvas.style.width = '100%';
      canvas.style.height = '100%';
      canvas.width = container.offsetWidth || container.clientWidth || 300;
      canvas.height = container.offsetHeight || container.clientHeight || 150;
      container.appendChild(canvas);
      var ctx = canvas.getContext('2d');
      var cfg = JSON.parse(JSON.stringify(config || {}));
      var num = cfg.particles.number.value || 50;
      var color = (cfg.particles.color && cfg.particles.color.value) || '#fff';
      var size = (cfg.particles.size && cfg.particles.size.value) || 3;
      var speed = (cfg.particles.move && cfg.particles.move.speed) || 1;
      var out_mode = (cfg.particles.move && cfg.particles.move.out_mode) || 'bounce';
      var link_enable = (cfg.particles.line_linked && cfg.particles.line_linked.enable);
      var link_dist = (cfg.particles.line_linked && cfg.particles.line_linked.distance) || 100;
      var link_color = (cfg.particles.line_linked && cfg.particles.line_linked.color) || color;
      var particles = [];
      var bounds = { w: canvas.width, h: canvas.height, out_mode: out_mode };
      function resize() {
        canvas.width = container.offsetWidth || container.clientWidth || 300;
        canvas.height = container.offsetHeight || container.clientHeight || 150;
        bounds.w = canvas.width;
        bounds.h = canvas.height;
      }
      window.addEventListener('resize', resize);
      var interactivity = cfg.interactivity || {};
      var onhover = (interactivity.events && interactivity.events.onhover && interactivity.events.onhover.enable);
      var onclick = (interactivity.events && interactivity.events.onclick && interactivity.events.onclick.enable);
      var grab_mode = (interactivity.events && interactivity.events.onhover && interactivity.events.onhover.mode) === 'grab';
      var push_mode = (interactivity.events && interactivity.events.onclick && interactivity.events.onclick.mode) === 'push';
      for (var i = 0; i < num; i++) {
        particles.push(new Particle(
          rand(0, bounds.w),
          rand(0, bounds.h),
          size,
          { x: rand(-speed, speed), y: rand(-speed, speed) },
          color
        ));
      }
      // FPS limiter and reduced motion support
      var lastFrame = 0;
      var fps = 30; // Target FPS
      var frameInterval = 1000 / fps;
      var prefersReduced = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;

      function draw(now) {
        // If reduced motion is requested, skip animation
        if (prefersReduced) {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          return;
        }
        now = now || performance.now();
        if (now - lastFrame < frameInterval) {
          requestAnimationFrame(draw);
          return;
        }
        lastFrame = now;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        for (var i = 0; i < particles.length; i++) {
          var p = particles[i];
          p.update(bounds);
          ctx.fillStyle = p.color;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
          ctx.fill();
        }
        if (link_enable) {
          for (var a = 0; a < particles.length; a++) {
            for (var b = a + 1; b < particles.length; b++) {
              var pa = particles[a], pb = particles[b];
              var dx = pa.x - pb.x, dy = pa.y - pb.y;
              var d = Math.sqrt(dx * dx + dy * dy);
              if (d < link_dist) {
                ctx.strokeStyle = link_color;
                ctx.globalAlpha = (1 - d / link_dist) * (cfg.particles.line_linked.opacity || 0.3);
                ctx.lineWidth = cfg.particles.line_linked.width || 1;
                ctx.beginPath();
                ctx.moveTo(pa.x, pa.y);
                ctx.lineTo(pb.x, pb.y);
                ctx.stroke();
                ctx.globalAlpha = 1;
              }
            }
          }
        }
        requestAnimationFrame(draw);
      }
      var mouse = { x: 0, y: 0 };
      if (onhover) {
        canvas.addEventListener('mousemove', function (e) {
          var rect = canvas.getBoundingClientRect();
          mouse.x = e.clientX - rect.left;
          mouse.y = e.clientY - rect.top;
        });
        if (grab_mode) {
          canvas.addEventListener('mousemove', function () {
            for (var i = 0; i < particles.length; i++) {
              var p = particles[i];
              var dx = p.x - mouse.x, dy = p.y - mouse.y;
              var d = Math.sqrt(dx * dx + dy * dy);
              if (d < (interactivity.modes && interactivity.modes.grab && interactivity.modes.grab.distance ? interactivity.modes.grab.distance : 140)) {
                ctx.beginPath();
                ctx.strokeStyle = (interactivity.modes && interactivity.modes.grab && interactivity.modes.grab.line_linked && interactivity.modes.grab.line_linked.color) ? interactivity.modes.grab.line_linked.color : link_color;
                ctx.globalAlpha = (1 - d / (interactivity.modes.grab.distance || 140)) * 0.6;
                ctx.moveTo(p.x, p.y);
                ctx.lineTo(mouse.x, mouse.y);
                ctx.stroke();
                ctx.globalAlpha = 1;
              }
            }
          });
        }
      }
      if (onclick && push_mode) {
        canvas.addEventListener('click', function (e) {
          for (var k = 0; k < (interactivity.modes && interactivity.modes.push && interactivity.modes.push.particles_nb ? interactivity.modes.push.particles_nb : 4); k++) {
            particles.push(new Particle(
              rand(0, bounds.w),
              rand(0, bounds.h),
              size,
              { x: rand(-speed, speed), y: rand(-speed, speed) },
              color
            ));
          }
        });
      }
      draw();
      instances[containerId] = { canvas: canvas, particles: particles, cfg: cfg };
      return instances[containerId];
    } catch (err) {
      console.warn('particles minimal failure', err);
    }
  };
})();
